# -------------------------------------------------------------------------
# Sliding Window Dynamic Mode Decomposition
#
# In this script we apply the sliding window method of dynamic mode
# decomposition (DMD) of Dylewsky, Tao, and Kutz (Physical Review E, 2019).
# The method is applied to synthetic data generated by a four-dimensional
# ordinary differential equation and then mixed via a random orthogonal
# matrix.
#
# The script proceeds by first applying standard DMD (see
# Schrodinger_DMD.m and Section 2.1 of the textbook) to the signal. This is
# used to demonstrate the weakness of the method for multiscale signals. We
# then follow this with an application of sliding window DMD, which
# drastically improves the performance in recreating the signal.
#
# To recreate the results from the manuscript, simply load the orthogonal
# matrix ortho_mat.mat provided in the repository.
#
# This script accompanies Section 2.2 of Data-Driven Methods for
# Dynamic Systems.
#
# This script was adapted from the MATLAB version by Jason J. Bramburger
# 
# Author: Mohit Sahu
# -------------------------------------------------------------------------
using DifferentialEquations, Plots, LinearAlgebra

# Model parameters
ϵ = 0.01;
Δ = 10;
p = [ϵ, Δ];

# ODE step parameters
dt = ϵ/100; # need lots of resolution for fast timescale
tspan = (0,2^6);

# Initial conditions
M = 4; # dimension of ODE
u0 = [0.0; 0.5; 0.0; 0.5];

function DiffEqu!(du,u,p, t)
    x1, x2, y1, y2 = u;
    ϵ, Δ = p;

    du[1] = x2;
    du[2] = -y1^2 * x1^3;
    du[3] = y2;
    du[4] = -ϵ^(-1)*y1 - Δ*y1^3;
    
end

# Integrate ODE
prob = ODEProblem(DiffEqu!, u0, tspan, p);
sol = solve(prob, saveat=dt)

t = sol.t;
x = reduce(hcat, sol.u);

# Random mixing of the signals
Q = rand(M,M);

# orthogonalize the rows
Q = (qr(Q').Q')' # Transpose, apply QR decomposition, then transpose back

# randomly make some components negative as well
signs = 2 .* rand(Bool, M) .- 1
Q = Q .* signs

using MAT
orth_math = matopen("orth_mat.mat")
Q = read(orth_math, "Q");
close(orth_math);

xdat = x' * Q;

# Plot multiscale dynamics
plot(t, xdat[:,1])
plot!(t, xdat[:,2])
plot!(t, xdat[:,3])
plot!(t, xdat[:,4])

# Apply standard DMD to multiscale signal
X = xdat[1:end-1,:]';
Y = xdat[2:end,:]';

# DMD matrix
A = Y*pinv(X);
F = eigen(A); # compute eigenvalues + eigenvectors
ev, D = F.values, F.vectors;
μ = diag(D); # extract eigenvalues

# Continuous time eigenvalues for reference
ω = @. log(μ)/dt;

# Forecast with DMD
N = length(t);
xforecast = zeros(M,N);
xforecast[:,1] = X[:,1];

# DMD forecast
for m = 1:N-1
    xforecast[:,m+1] = A*xforecast[:,m];
end

# Compare DMD forecast with data
# --> Plotting x_3(t) because the difference is easiest to see
plot(t,xdat[1:end,3],color=:blue,LineWidth=1)
plot!(t,xforecast[3,1:end],color=:red,LineWidth = 1)
xlabel!("t")
ylabel!("x₃(t)")

# Begin Window DMD
T = Int(1/dt); # Window width
step = 100; # forward step between windows - used to speed up computations
numWindows = Int((N-T-1)/step) + 1; # subtracting off 1 because N-1 is length of X and Y vectors above
ω = zeros(M,numWindows);
winMid = zeros(1,numWindows); # track the middle of the window for plotting
windowSolfast = zeros(Complex{Float64},M,length(t));
windowSolslow = zeros(Complex{Float64},M,length(t));
GaussSum = zeros(1,length(t));
sig = T*dt/8;

sig_sq_inv = 1 / sig^2;


function window_dmd(k)
    global windowSolfast;
    global windowSolslow;
    global GaussSum;
    global ω

    # Compute A matrix
    A = @views Y[:, (k - 1) * step + 1:(k - 1) * step + T] * pinv(@views X[:, (k - 1) * step + 1:(k - 1) * step + T]) # 0.003149 seconds

    # Eigen decomposition       
    F = eigen(A)
    ev = F.values
    V = F.vectors; 
    ω[:, k] = sort(@. abs((log(ev)/dt)^2));

    # Track the middle of the current window
    winMid[k] = t[(k - 1) * step + 1 + div(T, 2)]

    # Eigenvector coefficients
    b = pinv(V) * @views X[:, (k - 1) * step + 1]

    # Precompute terms used in the Gaussian and exponential components
    gauss = @. -(t - winMid[k])^2 * sig_sq_inv;

    for j in 1:2

        # error may be because complex nu may not be float
        windowSolfast .+= @views b[j] .* V[:, j] .* (exp.(gauss - 1im*imag(log(ev[j])/dt)*(t .- t[(k-1)*step + 1]) ))'
        windowSolslow .+= @views b[j + 2] .* V[:, j + 2] .* (exp.(gauss - 1im*imag(log(ev[j+2])/dt)*(t .- t[(k-1)*step + 1])))'
    end

    # Accumulate Gaussian sum for normalization
    GaussSum .+= exp.(gauss)';
end

@time window_dmd(1)  # 0.268402 seconds

for k=1:numWindows
    window_dmd(k);
end

# Normalize the solutions
windowSolfast = windowSolfast./GaussSum;
windowSolslow = windowSolslow./GaussSum;

# Combine fast and slow components
windowSol = windowSolfast + windowSolslow

# Plotting Frequency Results  (Check why it's coming wrong here)
scatter(winMid[1,:], ω[1,:], markercolor=:blue, ms=1)
scatter!(winMid[1,:], ω[3,:], markercolor=:red, ms=2)
xlabel!("Window Center")
ylabel!("|ωⱼᵏ|²")


# Signal Reconstruction Results
plot(t, xdat'[1,:], lw=2, lc=:blue)
plot!(t, real(windowsol[1,:]), lw=1, lc=:green)
xlabel!("t")
ylabel!("x(t)")

# Zoom of clusters with centroids plotted 
using Clustering
clust = kmeans(reshape(ω, (1, 25204)), 2)
idx = clust.assignments;
c = clust.centers;

p1 = scatter(winMid[1,:], ω[3,:], mc=:green,ms=1,markerstrokewidth = 0);
plot!(winMid[1,:], c[2].*ones(numWindows), lw=4, lc=:red,ls=:dash)
xlabel!("Window Center")
ylabel!("|ω₃ᵏ|²")

p2 = scatter(winMid[1,:], ω[1,:], mc=:blue,ms=1,markerstrokewidth = 0);
plot!(winMid[1,:], c[1].*ones(numWindows), lw=4, lc=:red,ls=:dash)
xlabel!("Window Center")
ylabel!("|ω₁ᵏ|²")

plot(p1, p2, layout=(2,1))

# Separating out slow and fast components
plot(t,xdat,lc=:blue,lw=1)
plot!(t,real(windowSolslow),lc=:green,lc=2)
plot!(t,real(windowSolfast),lc=:red,lw=1)
xlabel!("t")
ylabel!("x(t)")